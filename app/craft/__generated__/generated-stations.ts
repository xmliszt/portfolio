// Auto-generated file - DO NOT EDIT
// Generated by generate-station-code.js

export const stations = {
  'apple-vision-resize-handle': {
    'App.tsx': `import { useCallback, useRef, useState } from 'react';
import {
  AnimatePresence,
  motion,
  MotionConfig,
  useDragControls,
} from 'motion/react';

const variants = {
  initial: {
    opacity: 0,
    pathLength: 0,
  },
  animate: {
    opacity: 1,
    pathLength: 1,
  },
  exit: {
    opacity: 0,
    pathLength: 0,
  },
};

const PADDING = 8;
const MIN_SIZE = 100;

export default function AppleVisionResizeHandle() {
  const [draggingResizingCorner, setDraggingResizingCorner] = useState<
    'br' | 'bl' | undefined
  >(undefined);
  const activeResizingHandle = useRef<'br' | 'bl' | undefined>(undefined);

  const [size, setSize] = useState({ width: 100, height: 100 });
  const [isDragging, setIsDragging] = useState(false);

  const containerRef = useRef<HTMLDivElement>(null);
  const startPosRef = useRef({ x: 0, y: 0, width: 0, height: 0 });

  const dragControls = useDragControls();

  const handlePointerMove = useCallback((e: PointerEvent) => {
    const deltaX = e.clientX - startPosRef.current.x;
    const deltaY = e.clientY - startPosRef.current.y;

    // Calculate new dimensions based on which corner is being dragged
    // Using a 2x multiplier as container expands in both directions
    let newWidth = startPosRef.current.width;
    let newHeight = startPosRef.current.height;

    if (activeResizingHandle.current === 'br') {
      newWidth = Math.max(MIN_SIZE, startPosRef.current.width + deltaX * 2);
      newHeight = Math.max(MIN_SIZE, startPosRef.current.height + deltaY * 2);
    } else if (activeResizingHandle.current === 'bl') {
      newWidth = Math.max(MIN_SIZE, startPosRef.current.width - deltaX * 2);
      newHeight = Math.max(MIN_SIZE, startPosRef.current.height + deltaY * 2);
    }

    // Limit the size to the container
    if (containerRef.current) {
      const containerRect = containerRef.current.getBoundingClientRect();
      const maxWidth = containerRect.width - PADDING;
      const maxHeight = containerRect.height - PADDING;

      newWidth = Math.min(newWidth, maxWidth);
      newHeight = Math.min(newHeight, maxHeight);
    }

    setSize({ width: newWidth, height: newHeight });
  }, []);

  const handlePointerUp = useCallback(() => {
    setIsDragging(false);
    setDraggingResizingCorner(undefined);
    activeResizingHandle.current = undefined;

    window.removeEventListener('pointermove', handlePointerMove);
    window.removeEventListener('pointerup', handlePointerUp);
  }, [handlePointerMove]);

  const handlePointerDown = useCallback(
    (e: React.PointerEvent, handle: 'br' | 'bl') => {
      setIsDragging(true);
      setDraggingResizingCorner(handle);
      activeResizingHandle.current = handle;

      // Store initial position and size
      startPosRef.current = {
        x: e.clientX,
        y: e.clientY,
        width: size.width,
        height: size.height,
      };

      // Add event listeners for dragging
      window.addEventListener('pointermove', handlePointerMove);
      window.addEventListener('pointerup', handlePointerUp);
    },
    [size, handlePointerMove, handlePointerUp]
  );

  return (
    <MotionConfig transition={{ duration: 0.375, type: 'spring', bounce: 0 }}>
      <div
        className='relative flex h-screen w-screen items-center justify-center'
        style={{
          background:
            'url(https://images.unsplash.com/photo-1564078516393-cf04bd966897?q=80&w=3387&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D) no-repeat center bottom',
          backgroundSize: 'cover',
        }}
      >
        <div
          className='absolute inset-24 flex items-center justify-center'
          ref={containerRef}
        >
          <motion.div
            drag
            dragConstraints={containerRef}
            dragControls={dragControls}
            dragMomentum={false}
            dragListener={false}
            className='relative rounded-[20px] bg-neutral-500/30 shadow-[inset_0_0_5px_rgba(255,255,255,0.5)] backdrop-blur-md select-none'
            style={{
              width: \`\${size.width}px\`,
              height: \`\${size.height}px\`,
              transition: isDragging ? 'none' : 'width 0.2s, height 0.2s',
            }}
          >
            <div className='absolute inset-4 flex flex-col items-center justify-center gap-y-2 overflow-hidden rounded-[12px]'>
              <div className='relative z-10 flex flex-col items-center justify-center gap-y-2'>
                <div className='text-xs text-neutral-200'>
                  {Math.round(size.width)} Ã— {Math.round(size.height)}
                </div>
              </div>
            </div>

            <AnimatePresence>
              {(() => {
                if (!draggingResizingCorner) return null;
                switch (draggingResizingCorner) {
                  // bottom right corner resize handle
                  case 'br':
                    return (
                      <motion.div
                        key={draggingResizingCorner}
                        className='absolute right-0 bottom-0 size-10 overflow-visible'
                        initial={{ scale: 1, x: 16, y: 16 }}
                        animate={{ scale: isDragging ? 0.9 : 1, x: 16, y: 16 }}
                      >
                        <motion.svg
                          viewBox='0 0 30 30'
                          className='size-full'
                          fill='none'
                        >
                          <motion.path
                            d='M10,24 Q22,22 24,10'
                            stroke='white'
                            strokeWidth='4'
                            strokeLinecap='round'
                            strokeLinejoin='round'
                            fill='none'
                            opacity='0.7'
                            variants={variants}
                            initial='initial'
                            animate='animate'
                            exit='exit'
                          />
                        </motion.svg>
                      </motion.div>
                    );
                  // bottom left corner resize handle
                  case 'bl':
                    return (
                      <motion.div
                        key={draggingResizingCorner}
                        className='absolute bottom-0 left-0 size-10 overflow-visible'
                        initial={{ scale: 1, x: -16, y: 16 }}
                        animate={{ scale: isDragging ? 0.9 : 1, x: -16, y: 16 }}
                      >
                        <motion.svg
                          viewBox='0 0 30 30'
                          className='size-full'
                          fill='none'
                        >
                          <motion.path
                            d='M20,24 Q8,22 6,10'
                            stroke='white'
                            strokeWidth='4'
                            strokeLinecap='round'
                            strokeLinejoin='round'
                            fill='none'
                            opacity='0.7'
                            variants={variants}
                            initial='initial'
                            animate='animate'
                            exit='exit'
                          />
                        </motion.svg>
                      </motion.div>
                    );
                }
              })()}
              {/* bottom middle drag handle */}
              {draggingResizingCorner !== 'bl' &&
                draggingResizingCorner !== 'br' && (
                  <div className='absolute bottom-0 left-1/2 -translate-x-1/2 translate-y-[32px]'>
                    <motion.div
                      key={draggingResizingCorner}
                      className='h-full w-20 touch-none overflow-visible opacity-70'
                      onPointerDown={(event) =>
                        dragControls.start(event, { snapToCursor: false })
                      }
                      exit={{ scale: 1, opacity: 0 }}
                      whileHover={{ scale: 1, opacity: 1 }}
                      whileTap={{ scale: 0.9, opacity: 1 }}
                    >
                      <svg
                        viewBox='0 0 80 30'
                        className='size-full'
                        fill='none'
                      >
                        <path
                          d='M4,9 L76,9'
                          stroke='white'
                          strokeWidth='5.5'
                          strokeLinecap='round'
                          strokeLinejoin='round'
                          fill='none'
                        />
                      </svg>
                    </motion.div>
                  </div>
                )}
            </AnimatePresence>

            {/* pointer capture areas */}
            {/* bottom right corner resize handle capture area */}
            <div
              className='absolute right-0 bottom-0 size-10 translate-x-4 translate-y-4 cursor-default'
              onPointerEnter={useCallback(
                () => !isDragging && setDraggingResizingCorner('br'),
                [isDragging]
              )}
              onPointerLeave={useCallback(
                () => !isDragging && setDraggingResizingCorner(undefined),
                [isDragging]
              )}
              onPointerDown={(event) => handlePointerDown(event, 'br')}
              style={{ touchAction: 'none' }}
            />
            {/* bottom left corner resize handle capture area */}
            <div
              className='absolute bottom-0 left-0 size-10 -translate-x-4 translate-y-4 cursor-default'
              onPointerEnter={useCallback(
                () => !isDragging && setDraggingResizingCorner('bl'),
                [isDragging]
              )}
              onPointerLeave={useCallback(
                () => !isDragging && setDraggingResizingCorner(undefined),
                [isDragging]
              )}
              onPointerDown={(event) => handlePointerDown(event, 'bl')}
              style={{ touchAction: 'none' }}
            />
          </motion.div>
        </div>
        <p className='absolute bottom-6 px-4 text-center text-xs text-neutral-400 select-none'>
          Drag the bottom corners to resize the card. Drag the bottom middle to
          move the card.
        </p>
      </div>
    </MotionConfig>
  );
}
`,
  },
  'simple-stagger-paragraphs-enter-animation': {
    'App.tsx': `import './styles.css';

const PARAGRAPHS: string[] = [
  \`Welcome to Craft, a live playground where ideas transform into interactive experiences. This is where creativity meets code in real-time experimentation.\`,
  \`Craft provides a sandbox environment for developers to test animations, interactions, and design concepts without the overhead of setting up a complete project. Each station in Craft represents a focused exploration of a specific technique.\`,
  \`This particular station demonstrates staggered paragraph animations - a subtle yet effective way to guide the user's attention through content. Notice how each paragraph enters the viewport with a slight delay after the previous one.\`,
  \`The beauty of Craft lies in its simplicity. You can examine the code, understand the implementation, and immediately see the results. It's designed to inspire and educate through practical examples.\`,
];

export default function App() {
  return (
    <main className='flex h-screen w-screen justify-center overflow-y-auto p-8'>
      <div
        className='flex max-w-md flex-col gap-y-6'
        style={{
          '--delay': '120ms',
        }}
      >
        <h3>Craft</h3>
        {PARAGRAPHS.map((text, idx) => (
          <p
            key={text}
            style={{
              '--index': idx,
            }}
          >
            {text}
          </p>
        ))}
      </div>
    </main>
  );
}
`,
    'styles.css': `@import url('https://fonts.googleapis.com/css2?family=Newsreader:ital,opsz,wght@0,6..72,200..800;1,6..72,200..800&display=swap');

h3 {
  font-family: 'Newsreader', serif;
  font-style: italic;
  font-weight: 400;
}

p {
  font-weight: 300;
  font-size: 14px;
  animation: enter 0.6s ease-out;
  animation-delay: calc(var(--delay) * var(--index));
  animation-fill-mode: both;
}

@keyframes enter {
  from {
    opacity: 0;
    transform: translateY(10px);
    filter: blur(2px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
    filter: blur(0);
  }
}
`,
  },
  'text-morph-effect': {
    'App.tsx': `import { useEffect, useState } from 'react';
import { PlaneTakeoff } from 'lucide-react';
import { AnimatePresence, motion } from 'motion/react';

type MorphTextProps = {
  children: string;
};

function MorphText(props: MorphTextProps) {
  function createCharacters() {
    const characterCounts: { [char: string]: number } = {};
    return Array.from(props.children).map((char) => {
      if (!characterCounts[char]) characterCounts[char] = 1;
      const charKey = \`\${char}_\${characterCounts[char]}\`;
      characterCounts[char] += 1;

      return (
        <motion.span
          key={charKey}
          layoutId={charKey}
          className='inline-block'
          initial={{ opacity: 0, filter: 'blur(5px)' }}
          animate={{ opacity: 1, filter: 'blur(0px)' }}
          exit={{ opacity: 0, filter: 'blur(5px)' }}
          transition={{
            duration: 0.375,
            type: 'spring',
            bounce: 0,
          }}
        >
          {char === ' ' ? '\u00A0' : char}
        </motion.span>
      );
    });
  }

  return (
    <AnimatePresence mode='popLayout'>
      <div className='relative'>{createCharacters()}</div>
    </AnimatePresence>
  );
}

export default function App() {
  const [oldText, setOldText] = useState<string>('Gate open');
  const [newText, setNewText] = useState<string>('Boarding');
  const [displayText, setDisplayText] = useState<string>(oldText);

  const INTERVAL = 2000;
  useEffect(() => {
    const intervalId = setInterval(() => {
      if (displayText === oldText) setDisplayText(newText);
      else setDisplayText(oldText);
    }, INTERVAL);

    return () => clearInterval(intervalId);
  }, [oldText, newText, displayText]);

  return (
    <div className='flex h-screen w-screen items-center justify-center font-bold'>
      <div className='flex flex-col gap-y-8 p-2'>
        {/* Text display */}
        <div className='flex h-32 w-full items-center justify-center rounded-xl bg-neutral-100 p-4 shadow-inner select-none'>
          <div className='relative flex h-16 w-64 items-center justify-center rounded-xl bg-neutral-800 px-3 py-1.5 text-center text-lg text-neutral-100 shadow-lg'>
            <MorphText>{displayText}</MorphText>
            <PlaneTakeoff className='absolute top-2 left-2 size-4' />
          </div>
        </div>
        <div className='flex w-full flex-col gap-x-4 gap-y-4 sm:flex-row'>
          <div className='flex flex-col gap-y-1.5'>
            <label htmlFor='before-input' className='text-sm'>
              Before
            </label>
            <input
              id='before-input'
              className='h-10 w-full rounded-md bg-neutral-100 px-2.5 transition-all focus-visible:ring focus-visible:ring-neutral-800 focus-visible:outline-none sm:w-64'
              value={oldText}
              onChange={(e) => setOldText(e.target.value)}
              maxLength={16}
            />
          </div>
          <div className='flex flex-col gap-y-1.5'>
            <label htmlFor='after-input' className='text-sm'>
              After
            </label>
            <input
              id='after-input'
              className='h-10 w-full rounded-md bg-neutral-100 px-2.5 transition-all focus-visible:ring focus-visible:ring-neutral-800 focus-visible:outline-none sm:w-64'
              value={newText}
              onChange={(e) => setNewText(e.target.value)}
              maxLength={16}
            />
          </div>
        </div>
      </div>
    </div>
  );
}
`,
  },
  'three-d-rolling-slider': {
    'App.tsx': `import { useCallback, useRef, useState } from 'react';
import { Volume, Volume1, Volume2 } from 'lucide-react';
import { clamp, motion } from 'motion/react';

import { cn } from './utils';

type SliderProps = {
  /**
   * The value of the slider, between 0 and 100.
   */
  value: number;
  /**
   * The function to call when the slider value changes.
   */
  onChange?: (value: number) => void;
  /**
   * The content to display on the ball.
   */
  icon?: React.ReactNode;
  /**
   * Oritentation of the slider
   */
  orientation?: 'horizontal' | 'vertical';
  /**
   * Lenght of the slider
   */
  length?: number;
  /**
   * Lights up the positive range
   */
  showRange?: boolean;
  /**
   * Accent color
   */
  accentColor?: string;
};

function Slider({
  value,
  onChange,
  icon,
  orientation,
  length,
  showRange,
  accentColor,
}: SliderProps) {
  const [isDragging, setIsDragging] = useState(false);
  const containerRef = useRef<HTMLDivElement | null>(null);

  const accent = accentColor ?? '150 98% 57%';
  const sliderLength = length ?? 300;
  const direction = orientation ?? 'horizontal';

  const thumbValue = value * (sliderLength / 100);
  const thumbRotationValue = value * 3.6;

  const updateProgress = useCallback(
    (client: number) => {
      const containerElement = containerRef.current;
      if (!containerElement) return;
      const rect = containerElement.getBoundingClientRect();
      const clientPositionInContainer =
        client - (direction === 'horizontal' ? rect.x : rect.y);
      const effectiveClient =
        ((clientPositionInContainer - 28) / (sliderLength - 56)) * sliderLength;

      const percentage =
        (effectiveClient /
          (direction === 'horizontal' ? rect.width : rect.height)) *
        100;
      const effectivePercentage =
        direction === 'horizontal' ? percentage : 100 - percentage;
      onChange?.(clamp(0, 100, effectivePercentage));
    },
    [direction, sliderLength, onChange]
  );

  const handlePointerDown = (event: PointerEvent) => {
    event.preventDefault();
    event.stopPropagation();
    setIsDragging(true);
    updateProgress(direction === 'horizontal' ? event.clientX : event.clientY);

    const handlePointerMove = (event: PointerEvent) => {
      event.preventDefault();
      event.stopPropagation();
      updateProgress(
        direction === 'horizontal' ? event.clientX : event.clientY
      );
      setIsDragging(true);
    };

    const handlePointerUp = () => {
      window.removeEventListener('pointermove', handlePointerMove);
      window.removeEventListener('pointerup', handlePointerUp);
      setIsDragging(false);
    };

    window.addEventListener('pointermove', handlePointerMove);
    window.addEventListener('pointerup', handlePointerUp);
  };

  return (
    <div
      ref={containerRef}
      className='relative'
      style={{
        width: direction === 'horizontal' ? sliderLength : 24,
        height: direction === 'vertical' ? sliderLength : 24,
      }}
    >
      {/* Slider track */}
      <div
        className={cn(
          'absolute inset-0 rounded-full',
          'overflow-hidden bg-neutral-900'
        )}
      >
        {/* Slider range */}
        <motion.div
          className={cn(
            'absolute',
            direction === 'horizontal'
              ? 'top-1/2 left-0 origin-left rounded-l-full'
              : 'bottom-0 left-1/2 origin-bottom rounded-b-full'
          )}
          animate={{
            backgroundColor:
              isDragging || showRange === true ? \`hsl(\${accent})\` : '#171717',
            filter:
              isDragging || showRange === true
                ? \`drop-shadow(0 0 5px hsl(\${accent} / 60%))\`
                : \`drop-shadow(0 0 0px black))\`,
          }}
          style={{
            height:
              direction === 'vertical' ? \`calc(100% * \${value / 100})\` : '100%',
            width:
              direction === 'horizontal'
                ? \`calc(100% * \${value / 100})\`
                : '100%',
            translateX: direction === 'vertical' ? '-50%' : 0,
            translateY: direction === 'horizontal' ? '-50%' : 0,
          }}
        />

        {/* drop shadow overlay */}
        <div
          className={cn(
            'absolute inset-0 size-full rounded-[12px] shadow-[inset_0_0_10px_rgba(0,0,0,0.9)]'
          )}
        />
      </div>
      {/* Slider thumb */}
      <motion.div
        className={cn(
          'absolute size-14 cursor-grab touch-none overflow-hidden rounded-full',
          'shadow-[0_0_10px_rgba(0,0,0,0.5)]',
          direction === 'horizontal' ? 'top-1/2' : 'left-1/2'
        )}
        style={{
          y:
            direction === 'vertical'
              ? (sliderLength - 56) *
                  ((sliderLength - thumbValue) / sliderLength) +
                28
              : 0,
          x:
            direction === 'horizontal'
              ? (sliderLength - 56) * (thumbValue / sliderLength) + 28
              : 0,
          translateX: '-50%',
          translateY: '-50%',
        }}
        onPointerDown={(event) => handlePointerDown(event.nativeEvent)}
      >
        <div
          className={cn(
            'relative size-full',
            'bg-[radial-gradient(circle_at_center,#FFFFFF_0%,#444444_10%,#222222_34%,#000000_100%)]'
          )}
          style={{
            transformStyle: 'preserve-3d',
            perspective: '100px',
          }}
        >
          {Array.from({ length: 3 }).map((_, index, array) => {
            const rotationDeg =
              thumbRotationValue + index * (360 / array.length);

            return (
              <div
                key={index}
                className={cn('absolute top-1/2 left-1/2 origin-center')}
                style={{
                  transform:
                    direction === 'horizontal'
                      ? \`translate(-50%,-50%) rotateY(\${rotationDeg}deg) translateZ(28px)\`
                      : \`translate(-50%,-50%) rotateX(\${rotationDeg}deg) translateZ(28px)\`,
                }}
              >
                <span
                  className={cn('font-mono text-xs transition-colors')}
                  style={{
                    color: isDragging ? \`hsl(\${accent})\` : '#a1a1a1',
                    filter: isDragging
                      ? \`drop-shadow(0 0 4px hsl(\${accent}))\`
                      : 'drop-shadow(0 0 0px black)',
                  }}
                >
                  {icon ?? \`\${Math.round(value)}%\`}
                </span>
              </div>
            );
          })}
        </div>
      </motion.div>
    </div>
  );
}

export default function ThreeDRollingSlider() {
  // For volume example
  const [volume, setVolume] = useState(0);

  // For equalizer example
  const [eqValues, setEqValues] = useState<number[]>(Array(4).fill(0));

  return (
    <div className='relative h-screen w-screen bg-neutral-900 p-4 font-mono'>
      <div className='flex h-full w-full flex-col items-center justify-center gap-y-8'>
        <div className='flex flex-col gap-y-4'>
          <div className='text-sm text-neutral-600'>Volume</div>
          <Slider
            length={250}
            value={volume}
            onChange={setVolume}
            accentColor='0 0% 100%'
            showRange
            icon={(() => {
              switch (true) {
                case volume <= 33:
                  return <Volume className='size-4' />;
                case volume <= 66:
                  return <Volume1 className='size-4' />;
                default:
                  return <Volume2 className='size-4' />;
              }
            })()}
          />
        </div>
        <div className='flex flex-col gap-y-4'>
          <div className='text-sm text-neutral-600'>Equalizer</div>
          <div className='flex h-[300px] w-full gap-x-7 px-4'>
            {eqValues.map((val, idx) => (
              <div
                key={idx}
                className='flex h-full flex-col items-center gap-y-4'
              >
                <div className='text-xs text-neutral-300'>dB</div>
                <Slider
                  length={250}
                  orientation='vertical'
                  value={eqValues[idx]}
                  onChange={(value) =>
                    setEqValues((eqValues) => [
                      ...eqValues.slice(0, idx),
                      value,
                      ...eqValues.slice(idx + 1),
                    ])
                  }
                  showRange
                  accentColor={\`\${360 * (idx / eqValues.length)} 75% 60%\`}
                />
                <div className='text-xs text-neutral-300'>
                  {(() => {
                    switch (idx) {
                      case 0:
                        return '32Hz';
                      case 1:
                        return '64Hz';
                      case 2:
                        return '125Hz';
                      case 3:
                        return '250Hz';
                    }
                  })()}
                </div>
              </div>
            ))}
          </div>
        </div>
      </div>
    </div>
  );
}
`,
    'utils.ts': `import { type ClassValue, clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export function slugify(input: string) {
  // hash the input if it is not a string
  if (typeof input !== 'string') return '';
  const parts = input.split(' ');
  const encodedParts = parts.map((part) =>
    encodeURIComponent(part.toLowerCase())
  );
  return 'anchor:' + encodedParts.join('-');
}

export function isAtCurrentTOC(hash: string, tocTitle: string) {
  return hash === slugify(tocTitle);
}
`,
  },
} as const;
